## pydantic-resolve 和 GraphQL 框架比较

### GraphQL

优点

- client 可以根据查询动态获取数据
- 申明式的查询描述
- introspection 可以看到所有字段
- 强类型

缺点

- 缺少层级之间进行数据二次处理的能力. 比如上层无法在下层数据获取后进行额外操作.
- 查询体(文本)转换成具体类型不方便
- 框架对整个项目的影响较大

### Pydantic-resolve

pydantic-resolve 优点：

- 申明式的查询描述
- 强类型（pydantic）
- 提供了每层获取数据后进行处理的hook
- 对项目基本没有侵入性 (需要 async 支持)
- 一站式视图数据生成, 直接满足前端展示的所有需求

pydantic-resolve 缺点：

- 一个个单一入口, 没有GraphQL 阅读体验完整.


### 使用 GraphQL 的姿势

graphql 的使用思路有两种

一种是根据数据的ER，构建关系型查询
典型的比如github，jira 提供的graphql接口

用户熟悉这种固定的ER，查询到规范的数据之后自己再做二次加工。换言之你哪怕有定制化的需求，也只能自己想办法处理，不可能向他们提出这种要求。

另一种是面向业务，构建的是业务层的查询接口
这种场景并不适合graphql，他对查询的数据定制化要求高，意味着通过通用接口拿到的数据往往需要根据业务做再加工，而且也会和后端商量，定制一些面向专用页面的graphql 接口。

这会慢慢变成常态，导致很多不通用的查询出现. 并且很多数据并不适合暴露到前端做二次处理。

对于一整套业务流，graphql 这样一个灵活的中间层反而对垂直业务的整体清晰度造成了影响。

结论就是，graphql 适合稳定的，轻"具体"业务概念的数据的组合查询。而不适合面向具体业务，高度定制化的场景。